// ignore_for_file: non_constant_identifier_names, camel_case_types, missing_return, unused_import, unused_local_variable, dead_code, unnecessary_cast
//////////////////////////////////////////////////////////
// GENERATED BY FLUTTIFY. DO NOT EDIT IT.
//////////////////////////////////////////////////////////

import 'dart:typed_data';

import 'package:tmap_map_fluttify/src/ios/ios.export.g.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

import 'package:foundation_fluttify/foundation_fluttify.dart';
import 'package:core_location_fluttify/core_location_fluttify.dart';

class QMapView extends UIView  {
  //region constants
  static const String name__ = 'QMapView';

  @override
  final String tag__ = 'tmap_map_fluttify';

  
  //endregion

  //region creators
  static Future<QMapView> create__({ bool init = true /* ios only */ }) async {
    final refId = await MethodChannel('me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('ObjectFactory::createQMapView', {'init': init});
    final object = QMapView()..refId = refId;
    return object;
  }
  
  static Future<List<QMapView>> create_batch__(int length, { bool init = true /* ios only */ }) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
    final List resultBatch = await MethodChannel('me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('ObjectFactory::create_batchQMapView', {'length': length, 'init': init});
  
    final List<QMapView> typedResult = resultBatch.map((result) => QMapView()..refId = result).toList();
    return typedResult;
  }
  
  //endregion

  //region getters
  Future<bool> get_handDrawMapEnabled({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isHandDrawMapEnabled", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_showsTraffic({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsTraffic", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<QMapType> get_mapType({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_mapType", {'__this__': this});
    return __result__ == null ? null : ((__result__ as int).toQMapType());
  }
  
  Future<bool> get_showsScale({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsScale", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_showsBuildings({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsBuildings", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_shows3DBuildings({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_shows3DBuildings", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_showsPoi({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsPoi", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_showsCompass({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsCompass", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<QBasicMapViewLayer> get_animationLayer({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_animationLayer", {'__this__': this});
    return __result__ == null ? null : (QBasicMapViewLayer()..refId = __result__);
  }
  
  Future<CLLocationCoordinate2D> get_centerCoordinate({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_centerCoordinate", {'__this__': this});
    return __result__ == null ? null : (CLLocationCoordinate2D()..refId = __result__);
  }
  
  Future<double> get_zoomLevel({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_zoomLevel", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<double> get_minZoomLevel({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_minZoomLevel", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<double> get_maxZoomLevel({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_maxZoomLevel", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<double> get_rotation({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_rotation", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<double> get_overlooking({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_overlooking", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<QMapRect> get_visibleMapRect({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_visibleMapRect", {'__this__': this});
    return __result__ == null ? null : (QMapRect()..refId = __result__);
  }
  
  Future<QCoordinateRegion> get_region({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_region", {'__this__': this});
    return __result__ == null ? null : (QCoordinateRegion()..refId = __result__);
  }
  
  Future<bool> get_zoomEnabled({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isZoomEnabled", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_scrollEnabled({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isScrollEnabled", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_overlookingEnabled({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isOverlookingEnabled", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_rotateEnabled({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isRotateEnabled", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_indoorPicker({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_indoorPicker", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<CGPoint> get_indoorPickerOffset({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_indoorPickerOffset", {'__this__': this});
    return __result__ == null ? null : (CGPoint()..refId = __result__);
  }
  
  Future<QIndoorBuilding> get_activeBuilding({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_activeBuilding", {'__this__': this});
    return __result__ == null ? null : (QIndoorBuilding()..refId = __result__);
  }
  
  Future<QIndoorLevel> get_activeLevel({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_activeLevel", {'__this__': this});
    return __result__ == null ? null : (QIndoorLevel()..refId = __result__);
  }
  
  Future<bool> get_showsUserLocation({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsUserLocation", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<QUserLocation> get_userLocation({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_userLocation", {'__this__': this});
    return __result__ == null ? null : (QUserLocation()..refId = __result__);
  }
  
  Future<double> get_desiredAccuracy({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_desiredAccuracy", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<double> get_distanceFilter({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_distanceFilter", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<double> get_headingFilter({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_headingFilter", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_allowsBackgroundLocationUpdates({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_allowsBackgroundLocationUpdates", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_pausesLocationUpdatesAutomatically({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_pausesLocationUpdatesAutomatically", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<QUserTrackingMode> get_userTrackingMode({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_userTrackingMode", {'__this__': this});
    return __result__ == null ? null : ((__result__ as int).toQUserTrackingMode());
  }
  
  Future<bool> get_userLocationVisible({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isUserLocationVisible", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<List<dynamic>> get_annotations({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_annotations", {'__this__': this});
    return __result__ == null ? null : ((__result__ as List).cast<dynamic>());
  }
  
  Future<List<dynamic>> get_overlays({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_overlays", {'__this__': this});
    return __result__ == null ? null : ((__result__ as List).cast<dynamic>());
  }
  
  Future<String> get_userLocationAccessibilityLabel({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_userLocationAccessibilityLabel", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  Future<bool> get_annotationAccessibilityFrameClipToBounds({bool viewChannel = true}) async {
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_annotationAccessibilityFrameClipToBounds", {'__this__': this});
    return __result__ == null ? null : (__result__);
  }
  
  //endregion

  //region setters
  Future<void> set_handDrawMapEnabled(bool handDrawMapEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_handDrawMapEnabled', <String, dynamic>{'__this__': this, "handDrawMapEnabled": handDrawMapEnabled});
  
  
  }
  
  Future<void> set_showsTraffic(bool showsTraffic, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_showsTraffic', <String, dynamic>{'__this__': this, "showsTraffic": showsTraffic});
  
  
  }
  
  Future<void> set_delegate(QMapViewDelegate delegate, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_delegate', <String, dynamic>{'__this__': this, });
  
    MethodChannel('QMapViewDelegate::Callback@$refId', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify')))
      .setMethodCallHandler((methodCall) async {
        try {
          final args = methodCall.arguments as Map;
          switch (methodCall.method) {
            case 'Callback::QMapViewDelegate::mapViewInitComplete':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapViewInitComplete([\'mapView\':${args['mapView']}])');
              }
          
              // handle the native call
              delegate?.mapViewInitComplete(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>());
              break;
            case 'Callback::QMapViewDelegate::mapViewDidFailLoadingMap_withError':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapViewDidFailLoadingMap_withError([\'mapView\':${args['mapView']}, \'error\':${args['error']}])');
              }
          
              // handle the native call
              delegate?.mapViewDidFailLoadingMap_withError(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['error'] as Object))?.as__<NSError>());
              break;
            case 'Callback::QMapViewDelegate::mapView_regionWillChangeAnimated_gesture':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_regionWillChangeAnimated_gesture([\'mapView\':${args['mapView']}, \'animated\':${args['animated']}, \'bGesture\':${args['bGesture']}])');
              }
          
              // handle the native call
              delegate?.mapView_regionWillChangeAnimated_gesture(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), args['animated'], args['bGesture']);
              break;
            case 'Callback::QMapViewDelegate::mapViewRegionChange':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapViewRegionChange([\'mapView\':${args['mapView']}])');
              }
          
              // handle the native call
              delegate?.mapViewRegionChange(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>());
              break;
            case 'Callback::QMapViewDelegate::mapView_regionDidChangeAnimated_gesture':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_regionDidChangeAnimated_gesture([\'mapView\':${args['mapView']}, \'animated\':${args['animated']}, \'bGesture\':${args['bGesture']}])');
              }
          
              // handle the native call
              delegate?.mapView_regionDidChangeAnimated_gesture(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), args['animated'], args['bGesture']);
              break;
            case 'Callback::QMapViewDelegate::mapView_didTapAtCoordinate':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didTapAtCoordinate([\'mapView\':${args['mapView']}, \'coordinate\':${args['coordinate']}])');
              }
          
              // handle the native call
              delegate?.mapView_didTapAtCoordinate(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['coordinate'] as Object))?.as__<CLLocationCoordinate2D>());
              break;
            case 'Callback::QMapViewDelegate::mapView_didTapPoi':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didTapPoi([\'mapView\':${args['mapView']}, \'poi\':${args['poi']}])');
              }
          
              // handle the native call
              delegate?.mapView_didTapPoi(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['poi'] as Object))?.as__<QPoiInfo>());
              break;
            case 'Callback::QMapViewDelegate::mapView_didTapOverlay':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didTapOverlay([\'mapView\':${args['mapView']}, \'overlay\':${args['overlay']}])');
              }
          
              // handle the native call
              delegate?.mapView_didTapOverlay(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['overlay'] as Object))?.as__<QOverlay>());
              break;
            case 'Callback::QMapViewDelegate::mapView_viewForAnnotation':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_viewForAnnotation([\'mapView\':${args['mapView']}, \'annotation\':${args['annotation']}])');
              }
          
              // handle the native call
              delegate?.mapView_viewForAnnotation(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['annotation'] as Object))?.as__<QAnnotation>());
              break;
            case 'Callback::QMapViewDelegate::mapView_customCalloutForAnnotationView':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_customCalloutForAnnotationView([\'mapView\':${args['mapView']}, \'annotationView\':${args['annotationView']}])');
              }
          
              // handle the native call
              delegate?.mapView_customCalloutForAnnotationView(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['annotationView'] as Object))?.as__<QAnnotationView>());
              break;
            case 'Callback::QMapViewDelegate::mapView_didAddAnnotationViews':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didAddAnnotationViews([\'mapView\':${args['mapView']}, \'views\':${args['views']}])');
              }
          
              // handle the native call
              delegate?.mapView_didAddAnnotationViews(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), (args['views'] as List).cast<String>().map((__it__) => TypeOpTmapMapFluttifyIOS(__it__).as__<QAnnotationView>()).toList());
              break;
            case 'Callback::QMapViewDelegate::mapView_didSelectAnnotationView':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didSelectAnnotationView([\'mapView\':${args['mapView']}, \'view\':${args['view']}])');
              }
          
              // handle the native call
              delegate?.mapView_didSelectAnnotationView(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['view'] as Object))?.as__<QAnnotationView>());
              break;
            case 'Callback::QMapViewDelegate::mapView_didDeselectAnnotationView':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didDeselectAnnotationView([\'mapView\':${args['mapView']}, \'view\':${args['view']}])');
              }
          
              // handle the native call
              delegate?.mapView_didDeselectAnnotationView(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['view'] as Object))?.as__<QAnnotationView>());
              break;
            case 'Callback::QMapViewDelegate::mapView_annotationView_didChangeDragState_fromOldState':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_annotationView_didChangeDragState_fromOldState([\'mapView\':${args['mapView']}, \'view\':${args['view']}, \'newState\':${args['newState']}, \'oldState\':${args['oldState']}])');
              }
          
              // handle the native call
              delegate?.mapView_annotationView_didChangeDragState_fromOldState(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['view'] as Object))?.as__<QAnnotationView>(), (args['newState'] as int).toQAnnotationViewDragState(), (args['oldState'] as int).toQAnnotationViewDragState());
              break;
            case 'Callback::QMapViewDelegate::mapView_annotationView_calloutAccessoryControlTapped':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_annotationView_calloutAccessoryControlTapped([\'mapView\':${args['mapView']}, \'view\':${args['view']}, \'control\':${args['control']}])');
              }
          
              // handle the native call
              delegate?.mapView_annotationView_calloutAccessoryControlTapped(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['view'] as Object))?.as__<QAnnotationView>(), TypeOpTmapMapFluttifyIOS((args['control'] as Object))?.as__<UIControl>());
              break;
            case 'Callback::QMapViewDelegate::mapView_annotationViewCalloutTapped':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_annotationViewCalloutTapped([\'mapView\':${args['mapView']}, \'view\':${args['view']}])');
              }
          
              // handle the native call
              delegate?.mapView_annotationViewCalloutTapped(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['view'] as Object))?.as__<QAnnotationView>());
              break;
            case 'Callback::QMapViewDelegate::mapView_viewForOverlay':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_viewForOverlay([\'mapView\':${args['mapView']}, \'overlay\':${args['overlay']}])');
              }
          
              // handle the native call
              delegate?.mapView_viewForOverlay(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['overlay'] as Object))?.as__<QOverlay>());
              break;
            case 'Callback::QMapViewDelegate::mapView_didAddOverlayViews':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didAddOverlayViews([\'mapView\':${args['mapView']}, \'overlayViews\':${args['overlayViews']}])');
              }
          
              // handle the native call
              delegate?.mapView_didAddOverlayViews(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), (args['overlayViews'] as List).cast<String>().map((__it__) => TypeOpTmapMapFluttifyIOS(__it__).as__<NSObject>()).toList());
              break;
            case 'Callback::QMapViewDelegate::mapViewWillStartLocatingUser':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapViewWillStartLocatingUser([\'mapView\':${args['mapView']}])');
              }
          
              // handle the native call
              delegate?.mapViewWillStartLocatingUser(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>());
              break;
            case 'Callback::QMapViewDelegate::mapViewDidStopLocatingUser':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapViewDidStopLocatingUser([\'mapView\':${args['mapView']}])');
              }
          
              // handle the native call
              delegate?.mapViewDidStopLocatingUser(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>());
              break;
            case 'Callback::QMapViewDelegate::mapView_didUpdateUserLocation_fromHeading':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didUpdateUserLocation_fromHeading([\'mapView\':${args['mapView']}, \'userLocation\':${args['userLocation']}, \'fromHeading\':${args['fromHeading']}])');
              }
          
              // handle the native call
              delegate?.mapView_didUpdateUserLocation_fromHeading(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['userLocation'] as Object))?.as__<QUserLocation>(), args['fromHeading']);
              break;
            case 'Callback::QMapViewDelegate::mapView_didFailToLocateUserWithError':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didFailToLocateUserWithError([\'mapView\':${args['mapView']}, \'error\':${args['error']}])');
              }
          
              // handle the native call
              delegate?.mapView_didFailToLocateUserWithError(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), TypeOpTmapMapFluttifyIOS((args['error'] as Object))?.as__<NSError>());
              break;
            case 'Callback::QMapViewDelegate::mapView_didChangeUserTrackingMode_animated':
              // print log
              if (fluttifyLogEnabled) {
                debugPrint('fluttify-dart-callback: mapView_didChangeUserTrackingMode_animated([\'mapView\':${args['mapView']}, \'mode\':${args['mode']}, \'animated\':${args['animated']}])');
              }
          
              // handle the native call
              delegate?.mapView_didChangeUserTrackingMode_animated(TypeOpTmapMapFluttifyIOS((args['mapView'] as Object))?.as__<QMapView>(), (args['mode'] as int).toQUserTrackingMode(), args['animated']);
              break;
            default:
              break;
          }
        } catch (e) {
          debugPrint(e);
          throw e;
        }
      });
  }
  
  Future<void> set_mapType(QMapType mapType, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_mapType', <String, dynamic>{'__this__': this, "mapType": mapType.toValue()});
  
  
  }
  
  Future<void> set_showsScale(bool showsScale, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_showsScale', <String, dynamic>{'__this__': this, "showsScale": showsScale});
  
  
  }
  
  Future<void> set_showsBuildings(bool showsBuildings, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_showsBuildings', <String, dynamic>{'__this__': this, "showsBuildings": showsBuildings});
  
  
  }
  
  Future<void> set_shows3DBuildings(bool shows3DBuildings, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_shows3DBuildings', <String, dynamic>{'__this__': this, "shows3DBuildings": shows3DBuildings});
  
  
  }
  
  Future<void> set_showsPoi(bool showsPoi, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_showsPoi', <String, dynamic>{'__this__': this, "showsPoi": showsPoi});
  
  
  }
  
  Future<void> set_showsCompass(bool showsCompass, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_showsCompass', <String, dynamic>{'__this__': this, "showsCompass": showsCompass});
  
  
  }
  
  Future<void> set_centerCoordinate(CLLocationCoordinate2D centerCoordinate, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_centerCoordinate', <String, dynamic>{'__this__': this, "centerCoordinate": centerCoordinate});
  
  
  }
  
  Future<void> set_zoomLevel(double zoomLevel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_zoomLevel', <String, dynamic>{'__this__': this, "zoomLevel": zoomLevel});
  
  
  }
  
  Future<void> set_rotation(double rotation, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_rotation', <String, dynamic>{'__this__': this, "rotation": rotation});
  
  
  }
  
  Future<void> set_overlooking(double overlooking, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_overlooking', <String, dynamic>{'__this__': this, "overlooking": overlooking});
  
  
  }
  
  Future<void> set_visibleMapRect(QMapRect visibleMapRect, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_visibleMapRect', <String, dynamic>{'__this__': this, "visibleMapRect": visibleMapRect});
  
  
  }
  
  Future<void> set_region(QCoordinateRegion region, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_region', <String, dynamic>{'__this__': this, "region": region});
  
  
  }
  
  Future<void> set_zoomEnabled(bool zoomEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_zoomEnabled', <String, dynamic>{'__this__': this, "zoomEnabled": zoomEnabled});
  
  
  }
  
  Future<void> set_scrollEnabled(bool scrollEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_scrollEnabled', <String, dynamic>{'__this__': this, "scrollEnabled": scrollEnabled});
  
  
  }
  
  Future<void> set_overlookingEnabled(bool overlookingEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_overlookingEnabled', <String, dynamic>{'__this__': this, "overlookingEnabled": overlookingEnabled});
  
  
  }
  
  Future<void> set_rotateEnabled(bool rotateEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_rotateEnabled', <String, dynamic>{'__this__': this, "rotateEnabled": rotateEnabled});
  
  
  }
  
  Future<void> set_indoorPicker(bool indoorPicker, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_indoorPicker', <String, dynamic>{'__this__': this, "indoorPicker": indoorPicker});
  
  
  }
  
  Future<void> set_indoorPickerOffset(CGPoint indoorPickerOffset, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_indoorPickerOffset', <String, dynamic>{'__this__': this, "indoorPickerOffset": indoorPickerOffset});
  
  
  }
  
  Future<void> set_activeLevel(QIndoorLevel activeLevel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_activeLevel', <String, dynamic>{'__this__': this, "activeLevel": activeLevel});
  
  
  }
  
  Future<void> set_showsUserLocation(bool showsUserLocation, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_showsUserLocation', <String, dynamic>{'__this__': this, "showsUserLocation": showsUserLocation});
  
  
  }
  
  Future<void> set_desiredAccuracy(double desiredAccuracy, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_desiredAccuracy', <String, dynamic>{'__this__': this, "desiredAccuracy": desiredAccuracy});
  
  
  }
  
  Future<void> set_distanceFilter(double distanceFilter, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_distanceFilter', <String, dynamic>{'__this__': this, "distanceFilter": distanceFilter});
  
  
  }
  
  Future<void> set_headingFilter(double headingFilter, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_headingFilter', <String, dynamic>{'__this__': this, "headingFilter": headingFilter});
  
  
  }
  
  Future<void> set_allowsBackgroundLocationUpdates(bool allowsBackgroundLocationUpdates, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_allowsBackgroundLocationUpdates', <String, dynamic>{'__this__': this, "allowsBackgroundLocationUpdates": allowsBackgroundLocationUpdates});
  
  
  }
  
  Future<void> set_pausesLocationUpdatesAutomatically(bool pausesLocationUpdatesAutomatically, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_pausesLocationUpdatesAutomatically', <String, dynamic>{'__this__': this, "pausesLocationUpdatesAutomatically": pausesLocationUpdatesAutomatically});
  
  
  }
  
  Future<void> set_userTrackingMode(QUserTrackingMode userTrackingMode, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_userTrackingMode', <String, dynamic>{'__this__': this, "userTrackingMode": userTrackingMode.toValue()});
  
  
  }
  
  Future<void> set_userLocationAccessibilityLabel(String userLocationAccessibilityLabel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_userLocationAccessibilityLabel', <String, dynamic>{'__this__': this, "userLocationAccessibilityLabel": userLocationAccessibilityLabel});
  
  
  }
  
  Future<void> set_annotationAccessibilityFrameClipToBounds(bool annotationAccessibilityFrameClipToBounds, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::set_annotationAccessibilityFrameClipToBounds', <String, dynamic>{'__this__': this, "annotationAccessibilityFrameClipToBounds": annotationAccessibilityFrameClipToBounds});
  
  
  }
  
  //endregion

  //region methods
  
  static Future<void> loadPrefferedResourceFilesFromDirectory(String path, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView::loadPrefferedResourceFilesFromDirectory([\'path\':$path])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::loadPrefferedResourceFilesFromDirectory', {"path": path});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setMapStyle(int styleType, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setMapStyle([\'styleType\':$styleType])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setMapStyle', {"styleType": styleType, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setCompassOffset(CGPoint offset, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setCompassOffset([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCompassOffset', {"offset": offset, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setForeignLanguage(QMapLanguage language, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setForeignLanguage([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setForeignLanguage', {"language": language.toValue(), "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setCenterOffsetY(double offset, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setCenterOffsetY([\'offset\':$offset])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCenterOffsetY', {"offset": offset, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setCenterOffset(CGPoint offset, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setCenterOffset([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCenterOffset', {"offset": offset, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setCenterOffset_animated(CGPoint offset, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setCenterOffset([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCenterOffset_animated', {"offset": offset, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setLogoOffset(CGPoint offset, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setLogoOffset([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setLogoOffset', {"offset": offset, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setLogoMargin_anchor(CGPoint margin, QMapLogoAnchor anchor, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setLogoMargin([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setLogoMargin_anchor', {"margin": margin, "anchor": anchor.toValue(), "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setLogoScale(double scale, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setLogoScale([\'scale\':$scale])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setLogoScale', {"scale": scale, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setScaleViewOffset(CGPoint offset, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setScaleViewOffset([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setScaleViewOffset', {"offset": offset, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setRoadEventVisible(bool visible, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setRoadEventVisible([\'visible\':$visible])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setRoadEventVisible', {"visible": visible, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setCenterCoordinate_animated(CLLocationCoordinate2D coordinate, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setCenterCoordinate([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCenterCoordinate_animated', {"coordinate": coordinate, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setMinZoomLevel_maxZoomLevel(double minZoomLevel, double maxZoomLevel, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setMinZoomLevel([\'minZoomLevel\':$minZoomLevel, \'maxZoomLevel\':$maxZoomLevel])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setMinZoomLevel_maxZoomLevel', {"minZoomLevel": minZoomLevel, "maxZoomLevel": maxZoomLevel, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setZoomLevel_animated(double zoomLevel, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setZoomLevel([\'zoomLevel\':$zoomLevel, \'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setZoomLevel_animated', {"zoomLevel": zoomLevel, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setRotation_animated(double rotation, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setRotation([\'rotation\':$rotation, \'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setRotation_animated', {"rotation": rotation, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setOverlooking_animated(double overlooking, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setOverlooking([\'overlooking\':$overlooking, \'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setOverlooking_animated', {"overlooking": overlooking, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setVisibleMapRect_animated(QMapRect mapRect, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setVisibleMapRect([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setVisibleMapRect_animated', {"mapRect": mapRect, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setVisibleMapRect_edgePadding_animated(QMapRect mapRect, UIEdgeInsets insets, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setVisibleMapRect([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setVisibleMapRect_edgePadding_animated', {"mapRect": mapRect, "insets": insets, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setRegion_animated(QCoordinateRegion region, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setRegion([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setRegion_animated', {"region": region, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setRegion_edgePadding_animated(QCoordinateRegion region, UIEdgeInsets insets, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setRegion([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setRegion_edgePadding_animated', {"region": region, "insets": insets, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<QMapRect> mapRectThatFits_edgePadding(QMapRect mapRect, UIEdgeInsets insets, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::mapRectThatFits([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::mapRectThatFits_edgePadding', {"mapRect": mapRect, "insets": insets, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = QMapRect()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<QMapRect> mapRectThatFits_containsCalloutView_annotations_edgePadding(QMapRect mapRect, bool bContainsCalloutView, List<QAnnotation> annotations, UIEdgeInsets insets, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::mapRectThatFits([\'bContainsCalloutView\':$bContainsCalloutView])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::mapRectThatFits_containsCalloutView_annotations_edgePadding', {"mapRect": mapRect, "bContainsCalloutView": bContainsCalloutView, "annotations": annotations, "insets": insets, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = QMapRect()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<double> zoomLevelThatFits_edgePadding_outCenterCoordinate(QMapRect mapRect, UIEdgeInsets insets, List<CLLocationCoordinate2D> outCoordinate, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::zoomLevelThatFits([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::zoomLevelThatFits_edgePadding_outCenterCoordinate', {"mapRect": mapRect, "insets": insets, "outCoordinate": outCoordinate, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setLimitMapRect_mode(QMapRect mapRect, QMapLimitRectFitMode mode, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setLimitMapRect([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setLimitMapRect_mode', {"mapRect": mapRect, "mode": mode.toValue(), "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<CGPoint> convertCoordinate_toPointToView(CLLocationCoordinate2D coordinate, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::convertCoordinate([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::convertCoordinate_toPointToView', {"coordinate": coordinate, "view": view, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = CGPoint()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<CLLocationCoordinate2D> convertPoint_toCoordinateFromView(CGPoint point, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::convertPoint([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::convertPoint_toCoordinateFromView', {"point": point, "view": view, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = CLLocationCoordinate2D()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<CGRect> convertRegion_toRectToView(QCoordinateRegion region, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::convertRegion([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::convertRegion_toRectToView', {"region": region, "view": view, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = CGRect()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<QCoordinateRegion> convertRect_toRegionFromView(CGRect rect, UIView view, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::convertRect([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::convertRect_toRegionFromView', {"rect": rect, "view": view, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = QCoordinateRegion()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setIndoorEnabled(bool indoorEnabled, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setIndoorEnabled([\'indoorEnabled\':$indoorEnabled])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setIndoorEnabled', {"indoorEnabled": indoorEnabled, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setActiveIndoorInfo(QIndoorInfo indoorInfo, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setActiveIndoorInfo([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setActiveIndoorInfo', {"indoorInfo": indoorInfo, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> configureUserLocationPresentation(QUserLocationPresentation presentation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::configureUserLocationPresentation([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::configureUserLocationPresentation', {"presentation": presentation, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setUserTrackingMode_animated(QUserTrackingMode mode, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setUserTrackingMode([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setUserTrackingMode_animated', {"mode": mode.toValue(), "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> setUserLocationHidden(bool hidden, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::setUserLocationHidden([\'hidden\':$hidden])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setUserLocationHidden', {"hidden": hidden, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> addAnnotation(QAnnotation annotation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::addAnnotation([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addAnnotation', {"annotation": annotation, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> addAnnotations(List<dynamic> annotations, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::addAnnotations([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addAnnotations', {"annotations": annotations, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> removeAnnotation(QAnnotation annotation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::removeAnnotation([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeAnnotation', {"annotation": annotation, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> removeAnnotations(List<dynamic> annotations, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::removeAnnotations([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeAnnotations', {"annotations": annotations, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<QAnnotationView> viewForAnnotation(QAnnotation annotation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::viewForAnnotation([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::viewForAnnotation', {"annotation": annotation, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = QAnnotationView()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<QAnnotationView> dequeueReusableAnnotationViewWithIdentifier(String identifier, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::dequeueReusableAnnotationViewWithIdentifier([\'identifier\':$identifier])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::dequeueReusableAnnotationViewWithIdentifier', {"identifier": identifier, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = QAnnotationView()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<void> bringAnnotationToFront(QAnnotation annotation, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::bringAnnotationToFront([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::bringAnnotationToFront', {"annotation": annotation, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> selectAnnotation_animated(QAnnotation annotation, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::selectAnnotation([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::selectAnnotation_animated', {"annotation": annotation, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> deselectAnnotation_animated(QAnnotation annotation, bool animated, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::deselectAnnotation([\'animated\':$animated])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::deselectAnnotation_animated', {"annotation": annotation, "animated": animated, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> addOverlay(QOverlay overlay, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::addOverlay([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addOverlay', {"overlay": overlay, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> addOverlays(List<QOverlay> overlays, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::addOverlays([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addOverlays', {"overlays": overlays, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> removeOverlay(QOverlay overlay, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::removeOverlay([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeOverlay', {"overlay": overlay, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> removeOverlays(List<QOverlay> overlays, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::removeOverlays([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeOverlays', {"overlays": overlays, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<QOverlayView> viewForOverlay(QOverlay overlay, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::viewForOverlay([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::viewForOverlay', {"overlay": overlay, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = QOverlayView()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<void> addCustomLayer(QCustomLayer layer, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::addCustomLayer([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addCustomLayer', {"layer": layer, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> removeCustomLayer(QCustomLayer layer, {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::removeCustomLayer([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeCustomLayer', {"layer": layer, "__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  @deprecated
  Future<UIImage> takeSnapshot({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::takeSnapshot([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::takeSnapshot', {"__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = UIImage()..refId = __result__;
      return __return__;
    }
  }
  
  
  Future<void> takeSnapshotInRect_completion(CGRect rect, void completion(UIImage resultImage), {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::takeSnapshotInRect([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::takeSnapshotInRect_completion', {"rect": rect, "__this__": this});
  
  
    // handle native call
    MethodChannel('void|UIImage*#resultImage::Callback@$refId', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify')))
        .setMethodCallHandler((methodCall) async {
          try {
            final args = methodCall.arguments as Map;
            switch (methodCall.method) {
              case 'Callback::void|UIImage*#resultImage::void|UIImage*#resultImage':
                // print log
                if (fluttifyLogEnabled) {
          
                }
          
                // handle the native call
                if (completion != null) completion(TypeOpTmapMapFluttifyIOS((args['resultImage'] as Object))?.as__<UIImage>());
                break;
              default:
                break;
            }
          } catch (e) {
            debugPrint(e);
            throw e;
          }
        });
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<void> takeSnapshotInRect_timeout_completion(CGRect rect, double timeout, void completion(UIImage resultImage), {bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::takeSnapshotInRect([\'timeout\':$timeout])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::takeSnapshotInRect_timeout_completion', {"rect": rect, "timeout": timeout, "__this__": this});
  
  
    // handle native call
    MethodChannel('void|UIImage*#resultImage::Callback@$refId', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify')))
        .setMethodCallHandler((methodCall) async {
          try {
            final args = methodCall.arguments as Map;
            switch (methodCall.method) {
              case 'Callback::void|UIImage*#resultImage::void|UIImage*#resultImage':
                // print log
                if (fluttifyLogEnabled) {
          
                }
          
                // handle the native call
                if (completion != null) completion(TypeOpTmapMapFluttifyIOS((args['resultImage'] as Object))?.as__<UIImage>());
                break;
              default:
                break;
            }
          } catch (e) {
            debugPrint(e);
            throw e;
          }
        });
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  
  Future<String> getDebugError({bool viewChannel = true}) async {
    // print log
    if (fluttifyLogEnabled) {
      debugPrint('fluttify-dart: QMapView@$refId::getDebugError([])');
    }
  
    // invoke native method
    final __result__ = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::getDebugError', {"__this__": this});
  
  
    // handle native call
  
  
    // convert native result to dart side object
    if (__result__ == null) {
      return null;
    } else {
      final __return__ = __result__;
      return __return__;
    }
  }
  
  //endregion

  @override
  String toString() {
    return 'QMapView{refId: $refId, runtimeType: $runtimeType, tag__: $tag__}';
  }
}

extension QMapView_Batch on List<QMapView> {
  //region getters
  Future<List<bool>> get_handDrawMapEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isHandDrawMapEnabled_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_showsTraffic_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsTraffic_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<QMapType>> get_mapType_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_mapType_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => (__result__ as int).toQMapType()).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_showsScale_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsScale_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_showsBuildings_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsBuildings_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_shows3DBuildings_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_shows3DBuildings_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_showsPoi_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsPoi_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_showsCompass_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsCompass_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<QBasicMapViewLayer>> get_animationLayer_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_animationLayer_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => QBasicMapViewLayer()..refId = __result__).toList();
    return typedResult;
  }
  
  Future<List<CLLocationCoordinate2D>> get_centerCoordinate_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_centerCoordinate_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => CLLocationCoordinate2D()..refId = __result__).toList();
    return typedResult;
  }
  
  Future<List<double>> get_zoomLevel_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_zoomLevel_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<double>> get_minZoomLevel_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_minZoomLevel_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<double>> get_maxZoomLevel_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_maxZoomLevel_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<double>> get_rotation_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_rotation_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<double>> get_overlooking_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_overlooking_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<QMapRect>> get_visibleMapRect_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_visibleMapRect_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => QMapRect()..refId = __result__).toList();
    return typedResult;
  }
  
  Future<List<QCoordinateRegion>> get_region_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_region_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => QCoordinateRegion()..refId = __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_zoomEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isZoomEnabled_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_scrollEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isScrollEnabled_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_overlookingEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isOverlookingEnabled_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_rotateEnabled_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isRotateEnabled_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_indoorPicker_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_indoorPicker_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<CGPoint>> get_indoorPickerOffset_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_indoorPickerOffset_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => CGPoint()..refId = __result__).toList();
    return typedResult;
  }
  
  Future<List<QIndoorBuilding>> get_activeBuilding_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_activeBuilding_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => QIndoorBuilding()..refId = __result__).toList();
    return typedResult;
  }
  
  Future<List<QIndoorLevel>> get_activeLevel_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_activeLevel_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => QIndoorLevel()..refId = __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_showsUserLocation_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_showsUserLocation_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<QUserLocation>> get_userLocation_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_userLocation_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => QUserLocation()..refId = __result__).toList();
    return typedResult;
  }
  
  Future<List<double>> get_desiredAccuracy_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_desiredAccuracy_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<double>> get_distanceFilter_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_distanceFilter_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<double>> get_headingFilter_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_headingFilter_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_allowsBackgroundLocationUpdates_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_allowsBackgroundLocationUpdates_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_pausesLocationUpdatesAutomatically_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_pausesLocationUpdatesAutomatically_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<QUserTrackingMode>> get_userTrackingMode_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_userTrackingMode_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => (__result__ as int).toQUserTrackingMode()).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_userLocationVisible_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_isUserLocationVisible_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<List<dynamic>>> get_annotations_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_annotations_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => (__result__ as List).cast<dynamic>()).toList();
    return typedResult;
  }
  
  Future<List<List<dynamic>>> get_overlays_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_overlays_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => (__result__ as List).cast<dynamic>()).toList();
    return typedResult;
  }
  
  Future<List<String>> get_userLocationAccessibilityLabel_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_userLocationAccessibilityLabel_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  Future<List<bool>> get_annotationAccessibilityFrameClipToBounds_batch({bool viewChannel = true}) async {
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod("QMapView::get_annotationAccessibilityFrameClipToBounds_batch", [for (final __item__ in this) {'__this__': __item__}]);
  
    final typedResult = (resultBatch as List).cast<bool>().map((__result__) => __result__).toList();
    return typedResult;
  }
  
  //endregion

  //region setters
  Future<void> set_handDrawMapEnabled_batch(List<bool> handDrawMapEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_handDrawMapEnabled_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "handDrawMapEnabled": handDrawMapEnabled[__i__]}]);
  
  
  }
  
  Future<void> set_showsTraffic_batch(List<bool> showsTraffic, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_showsTraffic_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "showsTraffic": showsTraffic[__i__]}]);
  
  
  }
  
  Future<void> set_mapType_batch(List<QMapType> mapType, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_mapType_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "mapType": mapType[__i__].toValue()}]);
  
  
  }
  
  Future<void> set_showsScale_batch(List<bool> showsScale, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_showsScale_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "showsScale": showsScale[__i__]}]);
  
  
  }
  
  Future<void> set_showsBuildings_batch(List<bool> showsBuildings, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_showsBuildings_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "showsBuildings": showsBuildings[__i__]}]);
  
  
  }
  
  Future<void> set_shows3DBuildings_batch(List<bool> shows3DBuildings, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_shows3DBuildings_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "shows3DBuildings": shows3DBuildings[__i__]}]);
  
  
  }
  
  Future<void> set_showsPoi_batch(List<bool> showsPoi, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_showsPoi_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "showsPoi": showsPoi[__i__]}]);
  
  
  }
  
  Future<void> set_showsCompass_batch(List<bool> showsCompass, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_showsCompass_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "showsCompass": showsCompass[__i__]}]);
  
  
  }
  
  Future<void> set_centerCoordinate_batch(List<CLLocationCoordinate2D> centerCoordinate, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_centerCoordinate_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "centerCoordinate": centerCoordinate[__i__]}]);
  
  
  }
  
  Future<void> set_zoomLevel_batch(List<double> zoomLevel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_zoomLevel_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "zoomLevel": zoomLevel[__i__]}]);
  
  
  }
  
  Future<void> set_rotation_batch(List<double> rotation, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_rotation_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "rotation": rotation[__i__]}]);
  
  
  }
  
  Future<void> set_overlooking_batch(List<double> overlooking, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_overlooking_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "overlooking": overlooking[__i__]}]);
  
  
  }
  
  Future<void> set_visibleMapRect_batch(List<QMapRect> visibleMapRect, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_visibleMapRect_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "visibleMapRect": visibleMapRect[__i__]}]);
  
  
  }
  
  Future<void> set_region_batch(List<QCoordinateRegion> region, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_region_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "region": region[__i__]}]);
  
  
  }
  
  Future<void> set_zoomEnabled_batch(List<bool> zoomEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_zoomEnabled_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "zoomEnabled": zoomEnabled[__i__]}]);
  
  
  }
  
  Future<void> set_scrollEnabled_batch(List<bool> scrollEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_scrollEnabled_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "scrollEnabled": scrollEnabled[__i__]}]);
  
  
  }
  
  Future<void> set_overlookingEnabled_batch(List<bool> overlookingEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_overlookingEnabled_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "overlookingEnabled": overlookingEnabled[__i__]}]);
  
  
  }
  
  Future<void> set_rotateEnabled_batch(List<bool> rotateEnabled, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_rotateEnabled_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "rotateEnabled": rotateEnabled[__i__]}]);
  
  
  }
  
  Future<void> set_indoorPicker_batch(List<bool> indoorPicker, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_indoorPicker_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "indoorPicker": indoorPicker[__i__]}]);
  
  
  }
  
  Future<void> set_indoorPickerOffset_batch(List<CGPoint> indoorPickerOffset, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_indoorPickerOffset_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "indoorPickerOffset": indoorPickerOffset[__i__]}]);
  
  
  }
  
  Future<void> set_activeLevel_batch(List<QIndoorLevel> activeLevel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_activeLevel_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "activeLevel": activeLevel[__i__]}]);
  
  
  }
  
  Future<void> set_showsUserLocation_batch(List<bool> showsUserLocation, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_showsUserLocation_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "showsUserLocation": showsUserLocation[__i__]}]);
  
  
  }
  
  Future<void> set_desiredAccuracy_batch(List<double> desiredAccuracy, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_desiredAccuracy_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "desiredAccuracy": desiredAccuracy[__i__]}]);
  
  
  }
  
  Future<void> set_distanceFilter_batch(List<double> distanceFilter, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_distanceFilter_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "distanceFilter": distanceFilter[__i__]}]);
  
  
  }
  
  Future<void> set_headingFilter_batch(List<double> headingFilter, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_headingFilter_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "headingFilter": headingFilter[__i__]}]);
  
  
  }
  
  Future<void> set_allowsBackgroundLocationUpdates_batch(List<bool> allowsBackgroundLocationUpdates, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_allowsBackgroundLocationUpdates_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "allowsBackgroundLocationUpdates": allowsBackgroundLocationUpdates[__i__]}]);
  
  
  }
  
  Future<void> set_pausesLocationUpdatesAutomatically_batch(List<bool> pausesLocationUpdatesAutomatically, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_pausesLocationUpdatesAutomatically_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "pausesLocationUpdatesAutomatically": pausesLocationUpdatesAutomatically[__i__]}]);
  
  
  }
  
  Future<void> set_userTrackingMode_batch(List<QUserTrackingMode> userTrackingMode, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_userTrackingMode_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "userTrackingMode": userTrackingMode[__i__].toValue()}]);
  
  
  }
  
  Future<void> set_userLocationAccessibilityLabel_batch(List<String> userLocationAccessibilityLabel, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_userLocationAccessibilityLabel_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "userLocationAccessibilityLabel": userLocationAccessibilityLabel[__i__]}]);
  
  
  }
  
  Future<void> set_annotationAccessibilityFrameClipToBounds_batch(List<bool> annotationAccessibilityFrameClipToBounds, {bool viewChannel = true}) async {
    await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec())).invokeMethod('QMapView::set_annotationAccessibilityFrameClipToBounds_batch', [for (int __i__ = 0; __i__ < length; __i__++) {'__this__': this[__i__], "annotationAccessibilityFrameClipToBounds": annotationAccessibilityFrameClipToBounds[__i__]}]);
  
  
  }
  
  //endregion

  //region methods
  
  static Future<List<void>> loadPrefferedResourceFilesFromDirectory_batch(List<String> path, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::loadPrefferedResourceFilesFromDirectory_batch', [for (int __i__ = 0; __i__ < path.length; __i__++) {"path": path[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setMapStyle_batch(List<int> styleType, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setMapStyle_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"styleType": styleType[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setCompassOffset_batch(List<CGPoint> offset, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCompassOffset_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"offset": offset[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setForeignLanguage_batch(List<QMapLanguage> language, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setForeignLanguage_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"language": language[__i__].toValue(), "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setCenterOffsetY_batch(List<double> offset, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCenterOffsetY_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"offset": offset[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setCenterOffset_batch(List<CGPoint> offset, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCenterOffset_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"offset": offset[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setCenterOffset_animated_batch(List<CGPoint> offset, List<bool> animated, {bool viewChannel = true}) async {
    if (offset.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCenterOffset_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"offset": offset[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setLogoOffset_batch(List<CGPoint> offset, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setLogoOffset_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"offset": offset[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setLogoMargin_anchor_batch(List<CGPoint> margin, List<QMapLogoAnchor> anchor, {bool viewChannel = true}) async {
    if (margin.length != anchor.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setLogoMargin_anchor_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"margin": margin[__i__], "anchor": anchor[__i__].toValue(), "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setLogoScale_batch(List<double> scale, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setLogoScale_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"scale": scale[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setScaleViewOffset_batch(List<CGPoint> offset, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setScaleViewOffset_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"offset": offset[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setRoadEventVisible_batch(List<bool> visible, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setRoadEventVisible_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"visible": visible[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setCenterCoordinate_animated_batch(List<CLLocationCoordinate2D> coordinate, List<bool> animated, {bool viewChannel = true}) async {
    if (coordinate.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setCenterCoordinate_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"coordinate": coordinate[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setMinZoomLevel_maxZoomLevel_batch(List<double> minZoomLevel, List<double> maxZoomLevel, {bool viewChannel = true}) async {
    if (minZoomLevel.length != maxZoomLevel.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setMinZoomLevel_maxZoomLevel_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"minZoomLevel": minZoomLevel[__i__], "maxZoomLevel": maxZoomLevel[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setZoomLevel_animated_batch(List<double> zoomLevel, List<bool> animated, {bool viewChannel = true}) async {
    if (zoomLevel.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setZoomLevel_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"zoomLevel": zoomLevel[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setRotation_animated_batch(List<double> rotation, List<bool> animated, {bool viewChannel = true}) async {
    if (rotation.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setRotation_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"rotation": rotation[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setOverlooking_animated_batch(List<double> overlooking, List<bool> animated, {bool viewChannel = true}) async {
    if (overlooking.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setOverlooking_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"overlooking": overlooking[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setVisibleMapRect_animated_batch(List<QMapRect> mapRect, List<bool> animated, {bool viewChannel = true}) async {
    if (mapRect.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setVisibleMapRect_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"mapRect": mapRect[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setVisibleMapRect_edgePadding_animated_batch(List<QMapRect> mapRect, List<UIEdgeInsets> insets, List<bool> animated, {bool viewChannel = true}) async {
    if (mapRect.length != insets.length || insets.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setVisibleMapRect_edgePadding_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"mapRect": mapRect[__i__], "insets": insets[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setRegion_animated_batch(List<QCoordinateRegion> region, List<bool> animated, {bool viewChannel = true}) async {
    if (region.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setRegion_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"region": region[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setRegion_edgePadding_animated_batch(List<QCoordinateRegion> region, List<UIEdgeInsets> insets, List<bool> animated, {bool viewChannel = true}) async {
    if (region.length != insets.length || insets.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setRegion_edgePadding_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"region": region[__i__], "insets": insets[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<QMapRect>> mapRectThatFits_edgePadding_batch(List<QMapRect> mapRect, List<UIEdgeInsets> insets, {bool viewChannel = true}) async {
    if (mapRect.length != insets.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::mapRectThatFits_edgePadding_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"mapRect": mapRect[__i__], "insets": insets[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => QMapRect()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<QMapRect>> mapRectThatFits_containsCalloutView_annotations_edgePadding_batch(List<QMapRect> mapRect, List<bool> bContainsCalloutView, List<List<QAnnotation>> annotations, List<UIEdgeInsets> insets, {bool viewChannel = true}) async {
    if (mapRect.length != bContainsCalloutView.length || bContainsCalloutView.length != annotations.length || annotations.length != insets.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::mapRectThatFits_containsCalloutView_annotations_edgePadding_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"mapRect": mapRect[__i__], "bContainsCalloutView": bContainsCalloutView[__i__], "annotations": annotations[__i__], "insets": insets[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => QMapRect()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<double>> zoomLevelThatFits_edgePadding_outCenterCoordinate_batch(List<QMapRect> mapRect, List<UIEdgeInsets> insets, List<List<CLLocationCoordinate2D>> outCoordinate, {bool viewChannel = true}) async {
    if (mapRect.length != insets.length || insets.length != outCoordinate.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::zoomLevelThatFits_edgePadding_outCenterCoordinate_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"mapRect": mapRect[__i__], "insets": insets[__i__], "outCoordinate": outCoordinate[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<double>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setLimitMapRect_mode_batch(List<QMapRect> mapRect, List<QMapLimitRectFitMode> mode, {bool viewChannel = true}) async {
    if (mapRect.length != mode.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setLimitMapRect_mode_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"mapRect": mapRect[__i__], "mode": mode[__i__].toValue(), "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<CGPoint>> convertCoordinate_toPointToView_batch(List<CLLocationCoordinate2D> coordinate, List<UIView> view, {bool viewChannel = true}) async {
    if (coordinate.length != view.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::convertCoordinate_toPointToView_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"coordinate": coordinate[__i__], "view": view[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => CGPoint()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<CLLocationCoordinate2D>> convertPoint_toCoordinateFromView_batch(List<CGPoint> point, List<UIView> view, {bool viewChannel = true}) async {
    if (point.length != view.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::convertPoint_toCoordinateFromView_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"point": point[__i__], "view": view[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => CLLocationCoordinate2D()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<CGRect>> convertRegion_toRectToView_batch(List<QCoordinateRegion> region, List<UIView> view, {bool viewChannel = true}) async {
    if (region.length != view.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::convertRegion_toRectToView_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"region": region[__i__], "view": view[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => CGRect()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<QCoordinateRegion>> convertRect_toRegionFromView_batch(List<CGRect> rect, List<UIView> view, {bool viewChannel = true}) async {
    if (rect.length != view.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::convertRect_toRegionFromView_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"rect": rect[__i__], "view": view[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => QCoordinateRegion()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setIndoorEnabled_batch(List<bool> indoorEnabled, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setIndoorEnabled_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"indoorEnabled": indoorEnabled[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setActiveIndoorInfo_batch(List<QIndoorInfo> indoorInfo, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setActiveIndoorInfo_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"indoorInfo": indoorInfo[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> configureUserLocationPresentation_batch(List<QUserLocationPresentation> presentation, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::configureUserLocationPresentation_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"presentation": presentation[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setUserTrackingMode_animated_batch(List<QUserTrackingMode> mode, List<bool> animated, {bool viewChannel = true}) async {
    if (mode.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setUserTrackingMode_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"mode": mode[__i__].toValue(), "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> setUserLocationHidden_batch(List<bool> hidden, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::setUserLocationHidden_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"hidden": hidden[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> addAnnotation_batch(List<QAnnotation> annotation, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addAnnotation_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"annotation": annotation[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> addAnnotations_batch(List<List<dynamic>> annotations, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addAnnotations_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"annotations": annotations[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> removeAnnotation_batch(List<QAnnotation> annotation, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeAnnotation_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"annotation": annotation[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> removeAnnotations_batch(List<List<dynamic>> annotations, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeAnnotations_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"annotations": annotations[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<QAnnotationView>> viewForAnnotation_batch(List<QAnnotation> annotation, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::viewForAnnotation_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"annotation": annotation[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => QAnnotationView()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<QAnnotationView>> dequeueReusableAnnotationViewWithIdentifier_batch(List<String> identifier, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::dequeueReusableAnnotationViewWithIdentifier_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"identifier": identifier[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => QAnnotationView()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> bringAnnotationToFront_batch(List<QAnnotation> annotation, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::bringAnnotationToFront_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"annotation": annotation[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> selectAnnotation_animated_batch(List<QAnnotation> annotation, List<bool> animated, {bool viewChannel = true}) async {
    if (annotation.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::selectAnnotation_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"annotation": annotation[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> deselectAnnotation_animated_batch(List<QAnnotation> annotation, List<bool> animated, {bool viewChannel = true}) async {
    if (annotation.length != animated.length) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::deselectAnnotation_animated_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"annotation": annotation[__i__], "animated": animated[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> addOverlay_batch(List<QOverlay> overlay, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addOverlay_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"overlay": overlay[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> addOverlays_batch(List<List<QOverlay>> overlays, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addOverlays_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"overlays": overlays[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> removeOverlay_batch(List<QOverlay> overlay, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeOverlay_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"overlay": overlay[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> removeOverlays_batch(List<List<QOverlay>> overlays, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeOverlays_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"overlays": overlays[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<QOverlayView>> viewForOverlay_batch(List<QOverlay> overlay, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::viewForOverlay_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"overlay": overlay[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => QOverlayView()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> addCustomLayer_batch(List<QCustomLayer> layer, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::addCustomLayer_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"layer": layer[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<void>> removeCustomLayer_batch(List<QCustomLayer> layer, {bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::removeCustomLayer_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"layer": layer[__i__], "__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  @deprecated
  Future<List<UIImage>> takeSnapshot_batch({bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::takeSnapshot_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => UIImage()..refId = __result__).toList();
      return typedResult;
    }
  }
  
  
  Future<List<String>> getDebugError_batch({bool viewChannel = true}) async {
    if (false) {
      return Future.error('all args must have same length!');
    }
  
    // invoke native method
    final resultBatch = await MethodChannel(viewChannel ? 'me.yohom/tmap_map_fluttify/QMapView' : 'me.yohom/tmap_map_fluttify', StandardMethodCodec(FluttifyMessageCodec('tmap_map_fluttify'))).invokeMethod('QMapView::getDebugError_batch', [for (int __i__ = 0; __i__ < length; __i__++) {"__this__": this[__i__]}]);
  
  
    // convert native result to dart side object
    if (resultBatch == null) {
      return null;
    } else {
      final typedResult = (resultBatch as List).cast<String>().map((__result__) => __result__).toList();
      return typedResult;
    }
  }
  
  //endregion
}